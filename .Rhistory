# use the mi function to do the actual imputation, specify how many independent chains to utilize, how many iterations to conduct, and the maximum amount of time the user is willing to wait for all the iterations of all the chains to finish
imputations <- mi(mi.df, n.iter = 30, n.chains = 4, max.minutes = 20)
data2impute <- data[,c("study.type", "Country", "Land.use...land.cover", "Intensity.broad", "Fertilization", "Irrigation", "Pesticides", "Grazing", "Mowing", "Clear.Cut.y.n.", "Selective.Logging.y.n.", "Partial.Logging.y.n.", "species.group", "trophic.level..species.guild", "richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "sampled.area", "sampled.size.unit", "product", "yield.unit", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure", "sampled.size.area", "sampled.size.unit.1")]
# convert the data.frame to a missing_data.frame, which is an enhanced version of a data.frame that includes metadata about the variables that is essential in a missing data context
mi.df <- missing_data.frame(data2impute)
# check whether the missing_data.frame constructor function initially guessed the appropriate class for each missing_variable, if not use change()
show(mi.df)
image(mi.df) ## get a sense of the raw data and their missingness patterns
# use the mi function to do the actual imputation, specify how many independent chains to utilize, how many iterations to conduct, and the maximum amount of time the user is willing to wait for all the iterations of all the chains to finish
imputations <- mi(mi.df, n.iter = 30, n.chains = 4, max.minutes = 20)
str(imputations)
summary(imputations)
library(metafor)
library(mice)
setwd("C:\\Users\\hoppek\\Documents\\GitHub\\LUBDES_MA") #KG
#setwd("C:\\Users\\kambach\\Desktop\\aktuelle Arbeiten\\SESYNC\\myAnalysis") #SK
#setwd("~/Dropbox/SESYNC-UFZ-sDiv-Call Biodiversity and Ecosystem Services/Meta-Analysis/DataAnalysis") #MB
source("RScripts/-01_load_table_directly_from_google.R")
4/v9JEf_4EB8-2LNS1buhOwCSkt08Q0YGZsIH3Fv1827w
gs_ls() #follow the displayed url, go to browser and enter your login credentials click accept and copy key back into R
library(devtools)
library(googlesheets)
gs_ls() #follow the displayed url, go to browser and enter your login credentials click accept and copy key back into R
devtools::install_github("jennybc/googlesheets") # documentation at:http://htmlpreview.github.io/?https://raw.githubusercontent.com/jennybc/googlesheets/master/vignettes/basic-usage.html and https://github.com/jennybc/googlesheets
gs_ls() #follow the displayed url, go to browser and enter your login credentials click accept and copy key back into R
gs_ls() # once authorized, this will list the files you have in GS
?break
?cat
?return
data <- read.csv("Input/LUBDES coding table v2 - 1. Coding Table version 2.csv",na.strings=c("NA",""))
str(data) # check variable types
data = data[-(which(is.na(data$richness.mean))),]
data = data[-(which(is.na(data$yield.mean))),]
data$study.case <- factor(paste(data$Study.ID,data$Case.ID,sep="_"))
library(mi)
data2impute <- data[,c("study.type", "Country", "Land.use...land.cover", "Intensity.broad", "Fertilization", "Irrigation", "Pesticides", "Grazing", "Mowing", "Clear.Cut.y.n.", "Selective.Logging.y.n.", "Partial.Logging.y.n.", "species.group", "trophic.level..species.guild", "richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "sampled.area", "sampled.size.unit", "product", "yield.unit", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure", "sampled.size.area", "sampled.size.unit.1")]
mi.df <- missing_data.frame(data2impute)
show(mi.df)
image(mi.df) ## get a sense of the raw data and their missingness patterns
imputations <- mi(mi.df, n.iter = 30, n.chains = 4, max.minutes = 20)
imputations <- mi(mi.df, n.iter = 10, n.chains = 4, max.minutes = 20)
data2impute <- data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")]
mi.df <- missing_data.frame(data2impute)
show(mi.df)
image(mi.df)
imputations <- mi(mi.df, n.iter = 10, n.chains = 4, max.minutes = 20)
data.imp <- round(mipply(imputations, mean, to.matrix = TRUE), 3)
data.complete <- complete(imputations)
?mipply
data.imp
?complete
data.complete <- complete(imputations, m=1)
rawdata <- read.csv("Input/LUBDES coding table v2 - 1. Coding Table version 2.csv",na.strings=c("NA",""))
### alternatively (and more elegant) read data DIRECTLY from google docs as described in script -01
#gs_ls() # once authorized, this will list the files you have in GS
#LUBDES_gsheet<- gs_title("LUBDES coding table v2") # load LUBDES  coding table, this crashes sometimes but seems to work as of April 22 2015
#data <- gs_read(LUBDES_gsheet, ws = "1. Coding Table version 2") # consume data from sheet 1
### NOTE: data loaded this way is of classes ‘tbl_df’ and 'data.frame', rather than only 'data.frame' which is needed for imputation.
#names(data)
str(rawdata) # check variable types
#dissmiss studies with missing mean for BD or yield
rawdata <- rawdata[-(which(is.na(rawdata$richness.mean))),]
rawdata <- rawdata[-(which(is.na(rawdata$yield.mean))),]
################################
### create study-case identifier
rawdata$study.case <- factor(paste(rawdata$Study.ID,rawdata$Case.ID,sep="_"))
#######################################################################
### apply imputation methods, impute BD and yield sd and then calculate se
# TO DO: Adapt package "mi" after Ellington et al 2015
library(mi)
### specify data frame for imputation
# Adding "latitude..N..S.", "longitude..E..W.", "Land.cover", "PES.category" cause error
# TO Do: standardize sampled.size.unit for BD and yield, so that sampled.area has the same unit overall, then sampled.size.unit becomes obsolete
#data2impute <- rawdata[,c("study.type", "Country", "Land.use...land.cover", "Intensity.broad", "Fertilization", "Irrigation", "Pesticides", "Grazing", "Mowing", "Clear.Cut.y.n.", "Selective.Logging.y.n.", "Partial.Logging.y.n.", "species.group", "trophic.level..species.guild", "richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "sampled.area", "sampled.size.unit", "product", "yield.unit", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure", "sampled.size.area", "sampled.size.unit.1")]
data2impute <- rawdata[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")]
### convert the data.frame to a missing_data.frame, which is an enhanced version of a data.frame that includes metadata about the variables that is essential in a missing data context
mi.df <- missing_data.frame(data2impute)
### check whether the missing_data.frame constructor function initially guessed the appropriate class for each missing_variable, if not use change()
show(mi.df)
### get a sense of the raw data and their missingness patterns
image(mi.df)
### use the mi function to do the actual imputation, specify how many independent chains to utilize, how many iterations to conduct, and the maximum amount of time the user is willing to wait for all the iterations of all the chains to finish
imputations <- mi(mi.df, n.iter = 20, n.chains = 4, max.minutes = 20)
### check convergence by calculating the mean over imputation chains
data.imp <- round(mipply(imputations, mean, to.matrix = TRUE), 3)
###  Complete the missing data frame, take results fo the mth imputation chain
data <- complete(imputations, m=1)
### calculate SE for richness and yield mean
data$richness.SE <- data$richness.SD/sqrt(data$X..of.samples.for.BD.measure)
data$yield.SE <- data$yield.SD/sqrt(data$X..of.samples.for.YD.measure)
?change
mi.df <- change(mi.df, "X..of.samples.for.BD.measure", what="type", to="count")
mi.df <- change(mi.df, "X..of.samples.for.YD.measure", what="type", to="count")
show(mi.df)
imputations <- mi(mi.df, n.iter = 20, n.chains = 4, max.minutes = 20)
data.imp <- round(mipply(imputations, mean, to.matrix = TRUE), 3)
(data.imp <- round(mipply(imputations, mean, to.matrix = TRUE), 3))
data <- complete(imputations, m=1)
data$richness.SE <- data$richness.SD/sqrt(data$X..of.samples.for.BD.measure)
data$yield.SE <- data$yield.SD/sqrt(data$X..of.samples.for.YD.measure)
ES.frame <- data.frame(matrix(ncol=36,nrow=0))
names(ES.frame) <- c("Study.ID","Case.ID","Low.LUI","High.LUI","Habitat.Type",
"Product","ES.From.BD","Fertilization","Irrigation","Pesticides",
"Grazing","Mowing","Clear.Cut","Selective.Logging","Partial.Logging",
"Additional.Treatment", "Date.Start","Date.End","Latitude","Longitude",
"Species.Group","Species.Subgroup","Trophic.Level","Richness.Mean.Low" ,
"Richness.SD.Low","Richness.N.Low","Richness.Plot.Size","Richness.Mean.High","Richness.SD.High",
"Richness.N.High","Yield.Mean.Low","Yield.SD.Low","Yield.N.Low","Yield.Mean.High" ,
"Yield.SD.High","Yield.N.High")
table.sort = function(dat.low,dat.high,low,high){
data.frame("Study.ID"=dat.low$Study.ID, "Case.ID" =dat.low$Case.ID,
"Low.LUI" = low, "High.LUI" = high,
"Land.use...land.cover" = dat.low$Land.use...land.cover, "Product" = dat.low$Product, "ES.From.BD" =dat.low$ES.measured.from.BD.,
"Fertilization" = paste(dat.low$Fertilization, dat.high$Fertilization, sep="_"),
"Irrigation" =paste(dat.low$Irrigation, dat.high$Irrigation, sep="_"),
"Pesticides" = paste(dat.low$Pesticides, dat.high$Pesticides, sep="_"),
"Grazing" =paste(dat.low$Grazing, dat.high$Grazing, sep="_"),
"Mowing" = paste(dat.low$Mowing, dat.high$Mowing, sep="_"),
"Clear.Cut" =paste(dat.low$Clear.Cut.y.n., dat.high$Clear.Cut.y.n., sep="_"),
"Selective.Logging" = paste(dat.low$Selective.Logging.y.n., dat.high$Selective.Logging.y.n., sep="_"),
"Partial.Logging" = paste(dat.low$Partial.Logging.y.n., dat.high$Partial.Logging.y.n., sep="_"),
"Additional.Treatment" =dat.high$Additional.Treatment,
"Date.Start" =dat.low$Date.of.study..start, "Date.End" =dat.low$Date.of.study..end,
"Latitude" =dat.low$latitude..N..S., "Longitude" =dat.low$longitude..E..W.,
"Species.Group" =dat.low$species.group, "Species.Subgroup" =dat.low$species.subgroup.if.provided, "Trophic.Level" =dat.low$trophic.level..species.guild,
#"Product" = dat.low$product,
"Richness.Mean.Low" =dat.low$richness.mean, "Richness.SD.Low" =dat.low$richness.SD, "Richness.N.Low" =dat.low$X..of.samples.for.BD.measure,
"Richness.Plot.Size" =dat.low$sampled.area,
"Richness.Mean.High" = dat.high$richness.mean, "Richness.SD.High" =dat.high$richness.SD, "Richness.N.High" =dat.high$X..of.samples.for.BD.measure,
"Yield.Mean.Low" =dat.low$yield.mean, "Yield.SD.Low" =dat.low$yield.SD, "Yield.N.Low" =dat.low$X..of.samples.for.YD.measure,
"Yield.Mean.High" =dat.high$yield.mean, "Yield.SD.High" =dat.high$yield.SD, "Yield.N.High" =dat.high$X..of.samples.for.YD.measure)
}
for(i in unique(paste(data$study.case,data$species.group,sep="-"))){
data.temp = subset(data, paste(data$study.case,data$species.group,sep="-") %in% i)
# for between broad LUI comparisons
temp.low = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI","pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "low")
temp.medium = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "medium")
temp.high = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "high")
# for within broad LUI comparisons
temp.low.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "low")
temp.low.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "low")
temp.medium.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "medium")
temp.medium.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "medium")
temp.high.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "high")
temp.high.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "high")
# table.sort broken? MB
if((nrow(temp.low) + nrow (temp.medium)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.medium,"low","medium"))}
if((nrow(temp.low) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.high,"low","high"))}
if((nrow(temp.medium) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium,temp.high,"medium","high"))}
if((nrow(temp.low.base) + nrow (temp.low.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low.base,temp.low.increase,"low","low"))}
if((nrow(temp.medium.base) + nrow (temp.medium.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium.base,temp.medium.increase,"medium","medium"))}
if((nrow(temp.high.base) + nrow (temp.high.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.high.base,temp.high.increase,"high","high"))}
print(i)
}
unique(paste(data$study.case,data$species.group,sep="-"))
paste(data$study.case,data$species.group,sep="-")
data <- read.csv("Input/LUBDES coding table v2 - 1. Coding Table version 2.csv",na.strings=c("NA",""))
### alternatively (and more elegant) read data DIRECTLY from google docs as described in script -01
#gs_ls() # once authorized, this will list the files you have in GS
#LUBDES_gsheet<- gs_title("LUBDES coding table v2") # load LUBDES  coding table, this crashes sometimes but seems to work as of April 22 2015
#data <- gs_read(LUBDES_gsheet, ws = "1. Coding Table version 2") # consume data from sheet 1
### NOTE: data loaded this way is of classes ‘tbl_df’ and 'data.frame', rather than only 'data.frame' which is needed for imputation.
#names(data)
str(data) # check variable types
#dissmiss studies with missing mean for BD or yield
data <- data[-(which(is.na(data$richness.mean))),]
data <- data[-(which(is.na(data$yield.mean))),]
################################
### create study-case identifier
data$study.case <- factor(paste(data$Study.ID,data$Case.ID,sep="_"))
data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")] <- complete(imputations, m=1)
### calculate SE for richness and yield mean
data$richness.SE <- data$richness.SD/sqrt(data$X..of.samples.for.BD.measure)
data$yield.SE <- data$yield.SD/sqrt(data$X..of.samples.for.YD.measure)
complete(imputations, m=1)
test <- complete(imputations)
names(test)
test <- complete(imputations,m=1)
names(test)
data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")] <- complete(imputations, m=1)[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")]
hist(data$yield.SE)
summary(data$yield.SE)
data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")] <- complete(imputations, m=1)[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")]
### calculate SE for richness and yield mean
data$richness.SE <- data$richness.SD/sqrt(data$X..of.samples.for.BD.measure)
data$yield.SE <- data$yield.SD/sqrt(data$X..of.samples.for.YD.measure)
summary(data$yield.SE)
summary(data$yield.SD)
show(mi.df)
hist(data2impute$yield.SD)
mi.df <- change_type(mi.df, c("X..of.samples.for.BD.measure","X..of.samples.for.YD.measure"), to="count")
mi.df <- change_link(mi.df, c("richness.SD","yield.SD"), to="log")
show(mi.df)
imputations <- mi(mi.df, n.iter = 20, n.chains = 4, max.minutes = 20)
data <- read.csv("Input/LUBDES coding table v2 - 1. Coding Table version 2.csv",na.strings=c("NA",""))
### alternatively (and more elegant) read data DIRECTLY from google docs as described in script -01
#gs_ls() # once authorized, this will list the files you have in GS
#LUBDES_gsheet<- gs_title("LUBDES coding table v2") # load LUBDES  coding table, this crashes sometimes but seems to work as of April 22 2015
#data <- gs_read(LUBDES_gsheet, ws = "1. Coding Table version 2") # consume data from sheet 1
### NOTE: data loaded this way is of classes ‘tbl_df’ and 'data.frame', rather than only 'data.frame' which is needed for imputation.
#names(data)
str(data) # check variable types
#dissmiss studies with missing mean for BD or yield
data <- data[-(which(is.na(data$richness.mean))),]
data <- data[-(which(is.na(data$yield.mean))),]
################################
### create study-case identifier
data$study.case <- factor(paste(data$Study.ID,data$Case.ID,sep="_"))
#######################################################################
### apply imputation methods, impute BD and yield sd and then calculate se
# TO DO: Adapt package "mi" after Ellington et al 2015
library(mi)
### specify data frame for imputation
# Adding "latitude..N..S.", "longitude..E..W.", "Land.cover", "PES.category" cause error
# TO Do: standardize sampled.size.unit for BD and yield, so that sampled.area has the same unit overall, then sampled.size.unit becomes obsolete
#data2impute <- data[,c("study.type", "Country", "Land.use...land.cover", "Intensity.broad", "Fertilization", "Irrigation", "Pesticides", "Grazing", "Mowing", "Clear.Cut.y.n.", "Selective.Logging.y.n.", "Partial.Logging.y.n.", "species.group", "trophic.level..species.guild", "richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "sampled.area", "sampled.size.unit", "product", "yield.unit", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure", "sampled.size.area", "sampled.size.unit.1")]
data2impute <- data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")]
### convert the data.frame to a missing_data.frame, which is an enhanced version of a data.frame that includes metadata about the variables that is essential in a missing data context
mi.df <- missing_data.frame(data2impute)
### check whether the missing_data.frame constructor function initially guessed the appropriate class for each missing_variable, if not use change()
show(mi.df)
mi.df <- change_type(mi.df, c("X..of.samples.for.BD.measure","X..of.samples.for.YD.measure"), to="count")
mi.df <- change_link(mi.df, c("richness.SD","yield.SD"), to="log")
### get a sense of the raw data and their missingness patterns
image(mi.df)
imputations <- mi(mi.df, n.iter = 20, n.chains = 4, max.minutes = 20)
imputations <- mi(mi.df, n.iter = 2, n.chains = 4, max.minutes = 20)
imp <- mice(data)
imp <- mice(data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")])
mat <- complete(imp, 'long')
library(mice)
mat <- complete(imp, 'long')
detach("package:mi", unload=TRUE)
mat <- complete(imp, 'long')
mat <- complete(imp)
data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")] <- complete(imp)
data$richness.SE <- data$richness.SD/sqrt(data$X..of.samples.for.BD.measure)
str(data)
unique(data$X..of.samples.forBD.measure)
unique(data$X..of.samples.for.BD.measure)
data$X..of.samples.for.BD.measure <- as.integer(data$X..of.samples.for.BD.measure)
summary(data$X..of.samples.for.BD.measure)
str(data)
imp <- mice(data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")])
data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")] <- complete(imp)
### calculate SE for richness and yield mean
data$richness.SE <- data$richness.SD/sqrt(data$X..of.samples.for.BD.measure)
data$yield.SE <- data$yield.SD/sqrt(data$X..of.samples.for.YD.measure)
data <- read.csv("Input/LUBDES coding table v2 - 1. Coding Table version 2.csv",na.strings=c("NA",""))
str(data) # check variable types
data$X..of.samples.for.BD.measure <- as.integer(data$X..of.samples.for.BD.measure)
data <- data[-(which(is.na(data$richness.mean))),]
data <- data[-(which(is.na(data$yield.mean))),]
data$study.case <- factor(paste(data$Study.ID,data$Case.ID,sep="_"))
imp <- mice(data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")])
data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")] <- complete(imp)
### calculate SE for richness and yield mean
data$richness.SE <- data$richness.SD/sqrt(data$X..of.samples.for.BD.measure)
data$yield.SE <- data$yield.SD/sqrt(data$X..of.samples.for.YD.measure)
summary(dara$yield.SD)
summary(data$yield.SD)
summary(data$richness.SD)
data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")] <- complete(imputations, m=1)[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")]
summary(data)
summary(data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")])
mi.df <- missing_data.frame(data2impute)
### check whether the missing_data.frame constructor function initially guessed the appropriate class for each missing_variable, if not use change()
show(mi.df)
mi.df <- change_type(mi.df, c("X..of.samples.for.BD.measure","X..of.samples.for.YD.measure"), to="count")
# mi.df <- change_link(mi.df, c("richness.SD","yield.SD"), to="log")
### get a sense of the raw data and their missingness patterns
image(mi.df)
### use the mi function to do the actual imputation, specify how many independent chains to utilize, how many iterations to conduct, and the maximum amount of time the user is willing to wait for all the iterations of all the chains to finish
imputations <- mi(mi.df, n.iter = 20, n.chains = 4, max.minutes = 20) # does not work: Error in checkForRemoteErrors(val) : 2 nodes produced errors; first error: cannot find valid starting values: please specify some
library(mi)
### specify data frame for imputation
# Adding "latitude..N..S.", "longitude..E..W.", "Land.cover", "PES.category" cause error
# TO Do: standardize sampled.size.unit for BD and yield, so that sampled.area has the same unit overall, then sampled.size.unit becomes obsolete
#data2impute <- data[,c("study.type", "Country", "Land.use...land.cover", "Intensity.broad", "Fertilization", "Irrigation", "Pesticides", "Grazing", "Mowing", "Clear.Cut.y.n.", "Selective.Logging.y.n.", "Partial.Logging.y.n.", "species.group", "trophic.level..species.guild", "richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "sampled.area", "sampled.size.unit", "product", "yield.unit", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure", "sampled.size.area", "sampled.size.unit.1")]
data2impute <- data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")]
### convert the data.frame to a missing_data.frame, which is an enhanced version of a data.frame that includes metadata about the variables that is essential in a missing data context
mi.df <- missing_data.frame(data2impute)
### check whether the missing_data.frame constructor function initially guessed the appropriate class for each missing_variable, if not use change()
show(mi.df)
mi.df <- change_type(mi.df, c("X..of.samples.for.BD.measure","X..of.samples.for.YD.measure"), to="count")
# mi.df <- change_link(mi.df, c("richness.SD","yield.SD"), to="log")
### get a sense of the raw data and their missingness patterns
image(mi.df)
### use the mi function to do the actual imputation, specify how many independent chains to utilize, how many iterations to conduct, and the maximum amount of time the user is willing to wait for all the iterations of all the chains to finish
imputations <- mi(mi.df, n.iter = 20, n.chains = 4, max.minutes = 20) # does not work: Error in checkForRemoteErrors(val) : 2 nodes produced errors; first error: cannot find valid starting values: please specify some
### check convergence by calculating the mean over imputation chains
(data.imp <- round(mipply(imputations, mean, to.matrix = TRUE), 3))
###  Complete the missing data frame, take results fo the mth imputation chain
data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")] <- complete(imputations, m=1)[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")]
summary(data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")])
(data.imp <- round(mipply(imputations, mean, to.matrix = TRUE), 3))
data <- read.csv("Input/LUBDES coding table v2 - 1. Coding Table version 2.csv",na.strings=c("NA",""))
#names(data)
str(data) # check variable types
data$X..of.samples.for.BD.measure <- as.integer(data$X..of.samples.for.BD.measure)
#dissmiss studies with missing mean for BD or yield
data <- data[-(which(is.na(data$richness.mean))),]
data <- data[-(which(is.na(data$yield.mean))),]
library(mice)
detach("package:mi", unload=TRUE)
imp <- mice(data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")])
data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")] <- complete(imp)
### calculate SE for richness and yield mean
data$richness.SE <- data$richness.SD/sqrt(data$X..of.samples.for.BD.measure)
data$yield.SE <- data$yield.SD/sqrt(data$X..of.samples.for.YD.measure)
summary(data[,c("richness.mean", "richness.SD", "X..of.samples.for.BD.measure", "yield.mean", "yield.SD", "X..of.samples.for.YD.measure")])
save(data, file="Input/data.Rdata")
load("Input/data.Rdata")
load("Input/data.Rdata")
library(metafor)
ES.frame <- data.frame(matrix(ncol=36,nrow=0))
names(ES.frame) <- c("Study.ID","Case.ID","Low.LUI","High.LUI","Habitat.Type",
"Product","ES.From.BD","Fertilization","Irrigation","Pesticides",
"Grazing","Mowing","Clear.Cut","Selective.Logging","Partial.Logging",
"Additional.Treatment", "Date.Start","Date.End","Latitude","Longitude",
"Species.Group","Species.Subgroup","Trophic.Level","Richness.Mean.Low" ,
"Richness.SD.Low","Richness.N.Low","Richness.Plot.Size","Richness.Mean.High","Richness.SD.High",
"Richness.N.High","Yield.Mean.Low","Yield.SD.Low","Yield.N.Low","Yield.Mean.High" ,
"Yield.SD.High","Yield.N.High")
table.sort = function(dat.low,dat.high,low,high){
data.frame("Study.ID"=dat.low$Study.ID, "Case.ID" =dat.low$Case.ID,
"Low.LUI" = low, "High.LUI" = high,
"Land.use...land.cover" = dat.low$Land.use...land.cover, "Product" = dat.low$Product, "ES.From.BD" =dat.low$ES.measured.from.BD.,
"Fertilization" = paste(dat.low$Fertilization, dat.high$Fertilization, sep="_"),
"Irrigation" =paste(dat.low$Irrigation, dat.high$Irrigation, sep="_"),
"Pesticides" = paste(dat.low$Pesticides, dat.high$Pesticides, sep="_"),
"Grazing" =paste(dat.low$Grazing, dat.high$Grazing, sep="_"),
"Mowing" = paste(dat.low$Mowing, dat.high$Mowing, sep="_"),
"Clear.Cut" =paste(dat.low$Clear.Cut.y.n., dat.high$Clear.Cut.y.n., sep="_"),
"Selective.Logging" = paste(dat.low$Selective.Logging.y.n., dat.high$Selective.Logging.y.n., sep="_"),
"Partial.Logging" = paste(dat.low$Partial.Logging.y.n., dat.high$Partial.Logging.y.n., sep="_"),
"Additional.Treatment" =dat.high$Additional.Treatment,
"Date.Start" =dat.low$Date.of.study..start, "Date.End" =dat.low$Date.of.study..end,
"Latitude" =dat.low$latitude..N..S., "Longitude" =dat.low$longitude..E..W.,
"Species.Group" =dat.low$species.group, "Species.Subgroup" =dat.low$species.subgroup.if.provided, "Trophic.Level" =dat.low$trophic.level..species.guild,
#"Product" = dat.low$product,
"Richness.Mean.Low" =dat.low$richness.mean, "Richness.SD.Low" =dat.low$richness.SD, "Richness.N.Low" =dat.low$X..of.samples.for.BD.measure,
"Richness.Plot.Size" =dat.low$sampled.area,
"Richness.Mean.High" = dat.high$richness.mean, "Richness.SD.High" =dat.high$richness.SD, "Richness.N.High" =dat.high$X..of.samples.for.BD.measure,
"Yield.Mean.Low" =dat.low$yield.mean, "Yield.SD.Low" =dat.low$yield.SD, "Yield.N.Low" =dat.low$X..of.samples.for.YD.measure,
"Yield.Mean.High" =dat.high$yield.mean, "Yield.SD.High" =dat.high$yield.SD, "Yield.N.High" =dat.high$X..of.samples.for.YD.measure)
}
unique(paste(data$study.case,data$species.group,sep="-"))
i <- unique(paste(data$study.case,data$species.group,sep="-"))[1]
data.temp = subset(data, paste(data$study.case,data$species.group,sep="-") %in% i)
# for between broad LUI comparisons
temp.low = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI","pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "low")
temp.medium = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "medium")
temp.high = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "high")
# for within broad LUI comparisons
temp.low.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "low")
temp.low.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "low")
temp.medium.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "medium")
temp.medium.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "medium")
temp.high.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "high")
temp.high.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "high")
# table.sort broken? MB
if((nrow(temp.low) + nrow (temp.medium)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.medium,"low","medium"))}
if((nrow(temp.low) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.high,"low","high"))}
if((nrow(temp.medium) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium,temp.high,"medium","high"))}
if((nrow(temp.low.base) + nrow (temp.low.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low.base,temp.low.increase,"low","low"))}
if((nrow(temp.medium.base) + nrow (temp.medium.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium.base,temp.medium.increase,"medium","medium"))}
if((nrow(temp.high.base) + nrow (temp.high.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.high.base,temp.high.increase,"high","high"))}
print(i)
}
data$study.case <- factor(paste(data$Study.ID,data$Case.ID,sep="_"))
save(data, file="Input/data.Rdata")
unique(paste(data$study.case,data$species.group,sep="-"))
data.temp = subset(data, paste(data$study.case,data$species.group,sep="-") %in% i)
i <- unique(paste(data$study.case,data$species.group,sep="-"))[1]
data.temp = subset(data, paste(data$study.case,data$species.group,sep="-") %in% i)
temp.low = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI","pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "low")
temp.medium = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "medium")
temp.medium
temp.high = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "high")
temp.low.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "low")
temp.low.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "low")
temp.medium.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "medium")
temp.medium.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "medium")
temp.high.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "high")
temp.high.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "high")
if((nrow(temp.low) + nrow (temp.medium)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.medium,"low","medium"))}
if((nrow(temp.low) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.high,"low","high"))}
if((nrow(temp.medium) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium,temp.high,"medium","high"))}
if((nrow(temp.low.base) + nrow (temp.low.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low.base,temp.low.increase,"low","low"))}
if((nrow(temp.medium.base) + nrow (temp.medium.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium.base,temp.medium.increase,"medium","medium"))}
if((nrow(temp.high.base) + nrow (temp.high.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.high.base,temp.high.increase,"high","high"))}
# TO DO: remove "pooled within one LUI", change l 83: paste(data$study.case,data$species.group,sep="-") to data$study.case
for(i in unique(paste(data$study.case,data$species.group,sep="-"))){
data.temp = subset(data, paste(data$study.case,data$species.group,sep="-") %in% i)
# for between broad LUI comparisons
temp.low = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI","pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "low")
temp.medium = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "medium")
temp.high = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "high")
# for within broad LUI comparisons
temp.low.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "low")
temp.low.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "low")
temp.medium.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "medium")
temp.medium.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "medium")
temp.high.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "high")
temp.high.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "high")
# table.sort broken? MB
if((nrow(temp.low) + nrow (temp.medium)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.medium,"low","medium"))}
if((nrow(temp.low) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.high,"low","high"))}
if((nrow(temp.medium) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium,temp.high,"medium","high"))}
if((nrow(temp.low.base) + nrow (temp.low.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low.base,temp.low.increase,"low","low"))}
if((nrow(temp.medium.base) + nrow (temp.medium.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium.base,temp.medium.increase,"medium","medium"))}
if((nrow(temp.high.base) + nrow (temp.high.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.high.base,temp.high.increase,"high","high"))}
print(i)
}
i <- "8118-Mariotte2013_1-non-woody plants"
data.temp = subset(data, paste(data$study.case,data$species.group,sep="-") %in% i)
# for between broad LUI comparisons
temp.low = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI","pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "low")
temp.medium = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "medium")
temp.high = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "high")
# for within broad LUI comparisons
temp.low.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "low")
temp.low.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "low")
temp.medium.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "medium")
temp.medium.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "medium")
temp.high.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "high")
temp.high.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "high")
data.temp
if((nrow(temp.low) + nrow (temp.medium)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.medium,"low","medium"))}
if((nrow(temp.low) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.high,"low","high"))}
if((nrow(temp.medium) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium,temp.high,"medium","high"))}
if((nrow(temp.low.base) + nrow (temp.low.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low.base,temp.low.increase,"low","low"))}
if((nrow(temp.medium.base) + nrow (temp.medium.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium.base,temp.medium.increase,"medium","medium"))}
if((nrow(temp.high.base) + nrow (temp.high.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.high.base,temp.high.increase,"high","high"))}
print(i)
for(i in unique(paste(data$study.case,data$species.group,sep="-"))){
print(i)
data.temp = subset(data, paste(data$study.case,data$species.group,sep="-") %in% i)
# for between broad LUI comparisons
temp.low = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI","pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "low")
temp.medium = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "medium")
temp.high = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "high")
# for within broad LUI comparisons
temp.low.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "low")
temp.low.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "low")
temp.medium.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "medium")
temp.medium.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "medium")
temp.high.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "high")
temp.high.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "high")
# table.sort broken? MB
if((nrow(temp.low) + nrow (temp.medium)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.medium,"low","medium"))}
if((nrow(temp.low) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.high,"low","high"))}
if((nrow(temp.medium) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium,temp.high,"medium","high"))}
if((nrow(temp.low.base) + nrow (temp.low.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low.base,temp.low.increase,"low","low"))}
if((nrow(temp.medium.base) + nrow (temp.medium.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.medium.base,temp.medium.increase,"medium","medium"))}
if((nrow(temp.high.base) + nrow (temp.high.increase)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.high.base,temp.high.increase,"high","high"))}
}
data.temp
?try
temp.low = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI","pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "low")
temp.medium = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "medium")
temp.high = subset(data.temp, Within.study.Intensity %in% c("single measure within one LUI","pooled within one LUI", "pooled measures within one LUI","baseline LUI", "increased LUI") & Intensity.broad   %in% "high")
# for within broad LUI comparisons
temp.low.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "low")
temp.low.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "low")
temp.medium.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "medium")
temp.medium.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "medium")
temp.high.base = subset(data.temp, Within.study.Intensity %in% "baseline LUI" & Intensity.broad   %in% "high")
temp.high.increase = subset(data.temp, Within.study.Intensity %in% "increased LUI" & Intensity.broad   %in% "high")
# table.sort broken? MB
if((nrow(temp.low) + nrow (temp.medium)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.medium,"low","medium"))}
if((nrow(temp.low) + nrow (temp.high)) == 2){
ES.frame = rbind(ES.frame,table.sort(temp.low,temp.high,"low","high"))}
temp.low
